<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ë¡œë´‡ ìµœë‹¨ê±°ë¦¬ ì²­ì†Œí•˜ê¸°</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Arial', sans-serif;
      margin: 20px;
      padding: 0;
      box-sizing: border-box;
    }
    h1 { color: #2c3e50; font-size: 24px; }
    .box {
      border: 2px solid #ccc;
      padding: 15px;
      background-color: #f9f9f9;
      margin-top: 10px;
    }
    table {
      border-collapse: collapse;
      margin-top: 10px;
      width: 100%;
      max-width: 400px;
    }
    td {
      width: 20%;
      height: 60px;
      border: 1px solid #333;
      text-align: center;
      vertical-align: middle;
      font-size: 20px;
      position: relative;
    }
    .robot { background-color: lightblue; }
    .obstacle { background-color: gray; }
    .goal { background-color: lightgreen; }
    #timer { font-size: 24px; color: #e74c3c; margin-top: 10px; }
    select, button, textarea {
      margin-top: 10px;
      padding: 8px;
      font-size: 16px;
      width: 100%;
      box-sizing: border-box;
    }
    .hint {
      font-size: 16px;
      margin-top: 10px;
      color: #2c3e50;
    }

    #touchControls { display: block; }
    @media (min-width: 768px) {
      #touchControls { display: none; }
    }

    .step-number {
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 12px;
      color: #555;
    }
  </style>
</head>
<body>

<h1>ë¡œë´‡ ìµœë‹¨ê±°ë¦¬ ì²­ì†Œí•˜ê¸°</h1>

<div class="box"> 
  <h3>ğŸ“˜ CT ë¬¸í•­</h3>
  <p><strong>ë¬¸ì œ ìƒí™©:</strong><br>
    ì¹´í”¼ë°”ë¼ê°€ ë§Œë“  ë¡œë´‡ ì²­ì†Œê¸°ê°€ ì•„ë˜ ê·¸ë¦¼ì²˜ëŸ¼ ìƒê¸´ 5Ã—5 ê²©ì ë°© ì•ˆì— ìˆìŠµë‹ˆë‹¤.<br>
    ë¡œë´‡ì€ í˜„ì¬ ì‹œì‘ ìœ„ì¹˜ (0,0)ì— ìˆìœ¼ë©°, ì¥ì• ë¬¼(X)ì„ í”¼í•´ ì“°ë ˆê¸° ë”ë¯¸(G)ê¹Œì§€ ì´ë™í•´ì•¼ í•©ë‹ˆë‹¤.<br>
    ë¡œë´‡ì€ í•œ ë²ˆì— ìƒ, í•˜, ì¢Œ, ìš°ë¡œ í•œ ì¹¸ì”©ë§Œ ì›€ì§ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  </p>
  <p><strong>[ë¬¸ì œ]</strong><br>
    ë¡œë´‡ì´ Gê¹Œì§€ ë„ë‹¬í•  ìˆ˜ ìˆëŠ” <strong>ìµœì†Œ ì´ë™ íšŸìˆ˜</strong>ë¥¼ êµ¬í•˜ì„¸ìš”.
  </p>
</div>

<div class="box">
  <h3>ğŸ“Œ ê²©ì ì…ë ¥ ì €ì¥ ë° ëœë¤ ìƒì„±</h3>
  <textarea id="gridInput" rows="5"></textarea>
  <button onclick="generateRandomGrid()">ğŸ”€ ëœë¤ ë¬¸ì œ ìƒì„±</button>
  <button onclick="saveProblem()">ğŸ’¾ ë¬¸ì œ ì €ì¥</button>
  <button onclick="restartGame()">ğŸ”„ ë‹¤ì‹œ ì‹œì‘í•˜ê¸°</button>
</div>

<div class="box">
  <h3>ğŸ§­ ê²©ì ë° ë¡œë´‡ ì´ë™</h3>
  <div id="swipeArea">
    <table id="grid"></table>
  </div>
</div>

<div class="box" id="touchControls" style="text-align:center; margin-top: 20px;">
  <h3>ğŸ“± í„°ì¹˜ ì¡°ì‘ (ëª¨ë°”ì¼ ì „ìš©)</h3>
  <div style="display: flex; justify-content: center; flex-direction: column; align-items: center; gap: 5px;">
    <button onclick="moveRobot(-1,0)">â¬†ï¸ ìœ„</button>
    <div>
      <button onclick="moveRobot(0,-1)">â¬…ï¸ ì™¼ìª½</button>
      <button onclick="moveRobot(1,0)">â¬‡ï¸ ì•„ë˜</button>
      <button onclick="moveRobot(0,1)">â¡ï¸ ì˜¤ë¥¸ìª½</button>
    </div>
  </div>
</div>

<div>
  <label for="timeSelect">ğŸ•’ ì‹œê°„ ì„¤ì •:</label>
  <select id="timeSelect">
    <option value="30">30ì´ˆ</option>
    <option value="60">1ë¶„</option>
    <option value="90">1ë¶„ 30ì´ˆ</option>
    <option value="120">2ë¶„</option>
  </select>
  <button onclick="startTimer()">â³ ì‹œê°„ ì‹œì‘</button>
  <button onclick="pauseTimer()">â¸ï¸ ì‹œê°„ ë©ˆì¶¤</button>
</div>

<div id="timer"></div>
<div class="hint" id="hintBox">ğŸ’¡ íŒíŠ¸: ìµœë‹¨ê±°ë¦¬ ê²½ë¡œë¥¼ ìƒê°í•´ë³´ì„¸ìš”!</div>

<script>
let gridData = [];
let robotPos = { x: 0, y: 0 };
let countdown;
let remainingTime = 0;
let timerPaused = false;
let timeExpired = false;
let moveCount = 0;
let shortestPathLength = 0;
let moveHistory = [];

function generateRandomGrid() {
  const options = ['.', '.', '.', '.', 'X'];
  const grid = [];
  for (let i = 0; i < 5; i++) {
    const row = [];
    for (let j = 0; j < 5; j++) {
      row.push(options[Math.floor(Math.random() * options.length)]);
    }
    grid.push(row);
  }
  grid[0][0] = 'S';
  grid[4][4] = 'G';
  document.getElementById("gridInput").value = grid.map(r => r.join(' ')).join('\n');
  loadGrid();
}

function saveProblem() {
  const blob = new Blob([document.getElementById("gridInput").value], { type: 'text/plain' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = "robot_problem.txt";
  link.click();
}

function loadGrid() {
  const input = document.getElementById("gridInput").value.trim();
  const rows = input.split('\n');
  gridData = rows.map(row => row.trim().split(/\s+/));
  for (let i = 0; i < gridData.length; i++) {
    for (let j = 0; j < gridData[i].length; j++) {
      if (gridData[i][j] === 'S') robotPos = { x: i, y: j };
    }
  }
  moveCount = 0;
  moveHistory = [];
  shortestPathLength = calculateShortestPath();
  drawGrid();
}

function drawGrid() {
  const table = document.getElementById("grid");
  table.innerHTML = '';
  for (let i = 0; i < 5; i++) {
    const row = table.insertRow();
    for (let j = 0; j < 5; j++) {
      const cell = row.insertCell();
      let value = gridData[i][j];
      cell.textContent = value === '.' ? '' : value;

      if (i === robotPos.x && j === robotPos.y) {
        cell.className = 'robot';
        cell.textContent = 'ğŸ¤–';
      } else if (value === 'X') {
        cell.className = 'obstacle';
      } else if (value === 'G') {
        cell.className = 'goal';
      }

      const historyIndex = moveHistory.findIndex(p => p.x === i && p.y === j);
      if (historyIndex !== -1) {
        const span = document.createElement('span');
        span.className = 'step-number';
        span.textContent = historyIndex + 1;
        cell.appendChild(span);
      }
    }
  }
}

function moveRobot(dx, dy) {
  if (timeExpired) return;
  const nx = robotPos.x + dx;
  const ny = robotPos.y + dy;
  if (nx < 0 || ny < 0 || nx >= 5 || ny >= 5) return;
  const nextCell = gridData[nx][ny];

  if (nextCell === 'X') {
    robotPos = { x: nx, y: ny };
    drawGrid();
    setTimeout(() => {
      document.getElementById("grid").rows[nx].cells[ny].textContent = 'ğŸ’¥';
    }, 100);
    clearInterval(countdown);
    alert("ğŸ’¥ ë¡œë´‡ì´ ì¥ì• ë¬¼ì— ë¶€ë”ªí˜”ìŠµë‹ˆë‹¤!");
    timeExpired = true;
    return;
  }

  robotPos = { x: nx, y: ny };
  moveCount++;
  moveHistory.push({ x: nx, y: ny });

  if (nextCell === 'G') {
    drawGrid();
    clearInterval(countdown);
    timeExpired = true;
    if (moveCount === shortestPathLength) {
      alert(`ğŸ‰ ë¯¸ì…˜ ì„±ê³µ! ìµœë‹¨ê²½ë¡œ(${shortestPathLength}íšŒ ì´ë™)ë¡œ ì²­ì†Œë¥¼ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤!`);
    } else {
      alert(`ğŸ‰ ë¯¸ì…˜ ì„±ê³µ! í•˜ì§€ë§Œ ìµœë‹¨ê²½ë¡œ(${shortestPathLength}íšŒ)ê°€ ì•„ë‹Œ ${moveCount}íšŒë¡œ ì²­ì†Œí–ˆìŠµë‹ˆë‹¤.`);
    }
  } else {
    drawGrid();
  }
}

document.addEventListener('keydown', function (e) {
  if (timerPaused || timeExpired) return;
  switch (e.key) {
    case 'ArrowUp': moveRobot(-1, 0); break;
    case 'ArrowDown': moveRobot(1, 0); break;
    case 'ArrowLeft': moveRobot(0, -1); break;
    case 'ArrowRight': moveRobot(0, 1); break;
  }
});

function restartGame() {
  clearInterval(countdown);
  document.getElementById("timer").innerText = '';
  timerPaused = false;
  timeExpired = false;
  loadGrid();
}

function startTimer() {
  clearInterval(countdown);
  remainingTime = parseInt(document.getElementById("timeSelect").value);
  timerPaused = false;
  timeExpired = false;
  updateTimerDisplay();
  countdown = setInterval(() => {
    if (!timerPaused) {
      remainingTime--;
      updateTimerDisplay();
      if (remainingTime <= 0) {
        clearInterval(countdown);
        showTimeoutPopup();
        timeExpired = true;
      }
    }
  }, 1000);
}

function pauseTimer() {
  timerPaused = !timerPaused;
  document.querySelector("button[onclick='pauseTimer()']").innerText = timerPaused ? "â–¶ï¸ ë‹¤ì‹œ ì‹œì‘" : "â¸ï¸ ì‹œê°„ ë©ˆì¶¤";
}

function updateTimerDisplay() {
  const m = String(Math.floor(remainingTime / 60)).padStart(2, '0');
  const s = String(remainingTime % 60).padStart(2, '0');
  document.getElementById("timer").innerText = `â³ ë‚¨ì€ ì‹œê°„: ${m}:${s}`;
}

function showTimeoutPopup() {
  alert("â° ì‹œê°„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! ë¡œë´‡ ì´ë™ì´ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.");
}

function calculateShortestPath() {
  const visited = Array.from({ length: 5 }, () => Array(5).fill(false));
  const queue = [];
  const dirs = [[1,0],[0,1],[-1,0],[0,-1]];
  let start, goal;
  for (let i = 0; i < 5; i++) {
    for (let j = 0; j < 5; j++) {
      if (gridData[i][j] === 'S') start = [i, j];
      if (gridData[i][j] === 'G') goal = [i, j];
    }
  }

  queue.push({ x: start[0], y: start[1], dist: 0 });
  visited[start[0]][start[1]] = true;

  while (queue.length > 0) {
    const { x, y, dist } = queue.shift();
    if (x === goal[0] && y === goal[1]) return dist;
    for (let [dx, dy] of dirs) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && ny >= 0 && nx < 5 && ny < 5 && !visited[nx][ny] && gridData[nx][ny] !== 'X') {
        visited[nx][ny] = true;
        queue.push({ x: nx, y: ny, dist: dist + 1 });
      }
    }
  }
  return Infinity;
}

window.onload = generateRandomGrid;
</script>

</body>
</html>
